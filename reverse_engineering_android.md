# Reverse Engineering Android
## Sign the app
-> generate keystore private key
```
keytool -genkey -v -keystore test.keystore -alias test -keyalg RSA -keysize 2048 -validity 10000
```

-> export certificate
```
keytool -export -rfc -keystore test.keystore -alias test -file test.cer
```

-> list certificate
```
keytool -v -list -keystore test.keystore
```

-> signing the app with jarsigner
```
jarsigner -sigalg SHA1withRSA -digestalg SHA1 -keystore test.keystore <apk_path> test
```

## Install .aab
-> generate keystore private key
```
keytool -genkey -v -keystore test.keystore -alias test -keyalg RSA -keysize 2048 -validity 10000
```
-> convert aab to apks
```
java -jar bundletool-all-1.15.4.jar build-apks --bundle "<aab_path>" --output=ok.apks --mode=universal
```
or
```
java -jar bundletool-all-1.15.4.jar build-apks --bundle "<aab_path>" --output=test.apks --ks C:\Users\user\test.keystore --ks-key-alias=test --key-pass=pass:<key_password> --ks-pass=pass:<keystore_password>
```
-> install apks
```
java -jar bundletool-all-1.15.4.jar install-apks --apks=C:\Users\user\Downloads\test.apks
```

## Smali Assembler and Disassembler
On Android, applications are primarily written in Java or Kotlin and compiled to Java bytecode. This bytecode is then translated into Dalvik bytecode or, more recently, ART (Android Runtime) bytecode. When disassembling an .apk file, the disassembled code is usually presented in a language called Smali, which is a human-readable representation of Dalvik or ART bytecode. Smali is Android specific and provides a human-readable view of the application code.

apk - .dex (Dalvik executable files) -> smali code (Assembler for Android)

### baksmali/smali
https://bitbucket.org/JesusFreke/smali/downloads/
```
cp test.apk test.zip
unzip test.zip
```
-> baksmali ( .dex -> smali code ) - Disassembler
```
java -jar baksmali.jar d test/classes.dex -o output
```
-> smali(smali code -> .dex ) - Assembler
```
java -jar smali.jar a output -o classes.dex
```
-> ziping
```
zip -r test.apk AndroidManifest.xml classes.dex res/ resources.arsc
```
-> signing the app with jarsigner
```
jarsigner -sigalg SHA1withRSA -digestalg SHA1 -keystore test.keystore test.apk test
```

### apktool
https://bitbucket.org/iBotPeaches/apktool/downloads/  

-> apktool decompiling ( .dex -> smali code)  
```
apktool d test.apk -o test
```  
-> recompile  
```
apktool b test -o test.apk
```
-> signing the app with jarsigner
```
jarsigner -sigalg SHA1withRSA -digestalg SHA1 -keystore test.keystore test.apk test
```

https://github.com/iBotPeaches/Apktool  

-> Doc - smali  
http://pallergabor.uw.hu/androidblog/dalvik_opcodes.html  
https://github.com/JesusFreke/smali/wiki/TypesMethodsAndFields  

## Dex to Java decompiler 
-> jadx  
https://github.com/skylot/jadx  

-> dex2jar + JD_GUI  
https://github.com/pxb1988/dex2jar  
https://github.com/java-decompiler/jd-gui  

-> enjarify + JD_GUI  
https://github.com/Storyyeller/enjarify
https://github.com/java-decompiler/jd-gui  

Ps:  
Modify the app = smali code with apktool  
Understand the app logic = .dex -> Java .class with jadx, enjarify/dex2jar + jd_gui

## Reverse Engineering React Native in bundle

```index.android.bundle``` is a package file that contains all the JavaScript code of the application developed in React Native. This file is generated during the application's compilation/packaging process. It includes not only the code that has been written, but also all the code from the libraries and dependencies that the application uses. 

Before being included in the bundle file, the JavaScript files are transpiled (usually using Babel) to ensure compatibility with the Android runtime environment. After transpiling, Metro Bundler (the standard bundler used by React Native) compiles all these files into a single bundle file - index.android.bundle.

### React Native Decompiler

An interesting decompiler to use is [react-native-decompiler](https://github.com/numandev1/react-native-decompiler), which is able to decompile React Native ``index.android.bundle`` files and Webpack bundles, making them significantly easier to read.

-> Running react-native-decompiler
```
npx react-native-decompiler -i ./index.android.bundle -o ./output
```

### hermes-dec
If the bundle was compiled using Hermes (a mobile-optimized JavaScript engine), the file will be binary and will not be supported by react-native-decompiler. In this case, it would be necessary to decompile using a tool that supports Hermes.  
Use https://github.com/P1sec/hermes-dec  
-> Decompile to pseudocode (which is still not valid JavaScript as it doesn't re-transcribe loop/conditional structures)
```
hbc-decompiler assets/index.android.bundle /tmp/my_output_file.js
```
-> Another option is to disassemble
```
hbc-disassembler assets/index.android.bundle /tmp/my_output_file.hasm
```

### Other
-> Use the unzip command directly on the APK file to extract it. Navigate to the assets folder to locate the index.android.bundle file

-> Create an HTML file with the following content  
```
<script src="./index.android.bundle"></script>
```

-> Open the HTML file in a browser and view the JavaScript code using the developer tools (DevTools) under the "Sources" tab.

### Dump Information About an Object File - Lib
-> located in: /data/data/<package_name>/lib/  
-> displays data from the binary file, revealing information from the read-only section (.rodata) constants, where constants and important data are located.
```
objdump -s lib.so
```
-> displays Information of external symbols About an Object File to facilitate the identification of functions and variations that can be accessed externally
```
nm -g lib.so
```

### Others
-> compile java file to .class
```
javac ok.java
```

-> convert class to dex
```
d8 ok.class
```

-> execute in avd
```
dalvikvm -cp classes.dex <class_name>
```

-> convert .dex to .oat
```
dex2oat --dex-file=classes.dex --oat-file=teste.oat
```
